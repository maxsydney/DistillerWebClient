// @generated by protobuf-ts 1.0.13 with parameters enable_angular_annotations,long_type_string
// @generated from protobuf file "SensorManagerMessaging.proto" (syntax proto3)
// tslint:disable
import { BinaryWriteOptions } from "@protobuf-ts/runtime";
import { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import { BinaryReadOptions } from "@protobuf-ts/runtime";
import { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { DS18B20Sensor } from "./DS18B20Messaging";
import { DS18B20Role } from "./DS18B20Messaging";
/**
 * @generated from protobuf message SensorManagerCommandMessage
 */
export interface SensorManagerCommandMessage {
    /**
     * @generated from protobuf field: SensorManagerCmdType cmdType = 1;
     */
    cmdType: SensorManagerCmdType;
}
/**
 * @generated from protobuf message FlowrateData
 */
export interface FlowrateData {
    /**
     * @generated from protobuf field: double refluxFlowrate = 1;
     */
    refluxFlowrate: number;
    /**
     * @generated from protobuf field: double productFlowrate = 2;
     */
    productFlowrate: number;
}
/**
 * @generated from protobuf message ConcentrationData
 */
export interface ConcentrationData {
    /**
     * @generated from protobuf field: double vapourConcentration = 1;
     */
    vapourConcentration: number;
    /**
     * @generated from protobuf field: double boilerConcentration = 2;
     */
    boilerConcentration: number;
}
/**
 * @generated from protobuf message AssignSensorCommand
 */
export interface AssignSensorCommand {
    /**
     * @generated from protobuf field: DS18B20Role role = 1;
     */
    role: DS18B20Role;
    /**
     * @generated from protobuf field: DS18B20Sensor sensor = 2;
     */
    sensor?: DS18B20Sensor;
}
/**
 * @generated from protobuf message TemperatureData
 */
export interface TemperatureData {
    /**
     * @generated from protobuf field: double headTemp = 1;
     */
    headTemp: number;
    /**
     * @generated from protobuf field: double refluxCondensorTemp = 2;
     */
    refluxCondensorTemp: number;
    /**
     * @generated from protobuf field: double prodCondensorTemp = 3;
     */
    prodCondensorTemp: number;
    /**
     * @generated from protobuf field: double radiatorTemp = 4;
     */
    radiatorTemp: number;
    /**
     * @generated from protobuf field: double boilerTemp = 5;
     */
    boilerTemp: number;
    /**
     * @generated from protobuf field: uint32 timeStamp = 6;
     */
    timeStamp: number;
}
/**
 * @generated from protobuf message DeviceData
 */
export interface DeviceData {
    /**
     * @generated from protobuf field: repeated DS18B20Sensor sensors = 1;
     */
    sensors: DS18B20Sensor[];
}
/**
 * @generated from protobuf enum SensorManagerCmdType
 */
export enum SensorManagerCmdType {
    /**
     * @generated from protobuf enum value: CMD_NONE = 0;
     */
    CMD_NONE = 0,
    /**
     * @generated from protobuf enum value: CMD_BROADCAST_SENSORS = 1;
     */
    CMD_BROADCAST_SENSORS = 1
}
/**
 * Type for protobuf message SensorManagerCommandMessage
 */
class SensorManagerCommandMessage$Type extends MessageType<SensorManagerCommandMessage> {
    constructor() {
        super("SensorManagerCommandMessage", [
            { no: 1, name: "cmdType", kind: "enum", T: () => ["SensorManagerCmdType", SensorManagerCmdType] }
        ]);
    }
    create(value?: PartialMessage<SensorManagerCommandMessage>): SensorManagerCommandMessage {
        const message = { cmdType: 0 };
        if (value !== undefined)
            reflectionMergePartial<SensorManagerCommandMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SensorManagerCommandMessage): SensorManagerCommandMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SensorManagerCmdType cmdType */ 1:
                    message.cmdType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SensorManagerCommandMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SensorManagerCmdType cmdType = 1; */
        if (message.cmdType !== 0)
            writer.tag(1, WireType.Varint).int32(message.cmdType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const SensorManagerCommandMessage = new SensorManagerCommandMessage$Type();
/**
 * Type for protobuf message FlowrateData
 */
class FlowrateData$Type extends MessageType<FlowrateData> {
    constructor() {
        super("FlowrateData", [
            { no: 1, name: "refluxFlowrate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "productFlowrate", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<FlowrateData>): FlowrateData {
        const message = { refluxFlowrate: 0, productFlowrate: 0 };
        if (value !== undefined)
            reflectionMergePartial<FlowrateData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FlowrateData): FlowrateData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double refluxFlowrate */ 1:
                    message.refluxFlowrate = reader.double();
                    break;
                case /* double productFlowrate */ 2:
                    message.productFlowrate = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FlowrateData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double refluxFlowrate = 1; */
        if (message.refluxFlowrate !== 0)
            writer.tag(1, WireType.Bit64).double(message.refluxFlowrate);
        /* double productFlowrate = 2; */
        if (message.productFlowrate !== 0)
            writer.tag(2, WireType.Bit64).double(message.productFlowrate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const FlowrateData = new FlowrateData$Type();
/**
 * Type for protobuf message ConcentrationData
 */
class ConcentrationData$Type extends MessageType<ConcentrationData> {
    constructor() {
        super("ConcentrationData", [
            { no: 1, name: "vapourConcentration", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "boilerConcentration", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<ConcentrationData>): ConcentrationData {
        const message = { vapourConcentration: 0, boilerConcentration: 0 };
        if (value !== undefined)
            reflectionMergePartial<ConcentrationData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConcentrationData): ConcentrationData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double vapourConcentration */ 1:
                    message.vapourConcentration = reader.double();
                    break;
                case /* double boilerConcentration */ 2:
                    message.boilerConcentration = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConcentrationData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double vapourConcentration = 1; */
        if (message.vapourConcentration !== 0)
            writer.tag(1, WireType.Bit64).double(message.vapourConcentration);
        /* double boilerConcentration = 2; */
        if (message.boilerConcentration !== 0)
            writer.tag(2, WireType.Bit64).double(message.boilerConcentration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const ConcentrationData = new ConcentrationData$Type();
/**
 * Type for protobuf message AssignSensorCommand
 */
class AssignSensorCommand$Type extends MessageType<AssignSensorCommand> {
    constructor() {
        super("AssignSensorCommand", [
            { no: 1, name: "role", kind: "enum", T: () => ["DS18B20Role", DS18B20Role] },
            { no: 2, name: "sensor", kind: "message", T: () => DS18B20Sensor }
        ]);
    }
    create(value?: PartialMessage<AssignSensorCommand>): AssignSensorCommand {
        const message = { role: 0 };
        if (value !== undefined)
            reflectionMergePartial<AssignSensorCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssignSensorCommand): AssignSensorCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* DS18B20Role role */ 1:
                    message.role = reader.int32();
                    break;
                case /* DS18B20Sensor sensor */ 2:
                    message.sensor = DS18B20Sensor.internalBinaryRead(reader, reader.uint32(), options, message.sensor);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssignSensorCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* DS18B20Role role = 1; */
        if (message.role !== 0)
            writer.tag(1, WireType.Varint).int32(message.role);
        /* DS18B20Sensor sensor = 2; */
        if (message.sensor)
            DS18B20Sensor.internalBinaryWrite(message.sensor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const AssignSensorCommand = new AssignSensorCommand$Type();
/**
 * Type for protobuf message TemperatureData
 */
class TemperatureData$Type extends MessageType<TemperatureData> {
    constructor() {
        super("TemperatureData", [
            { no: 1, name: "headTemp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "refluxCondensorTemp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "prodCondensorTemp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "radiatorTemp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "boilerTemp", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "timeStamp", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TemperatureData>): TemperatureData {
        const message = { headTemp: 0, refluxCondensorTemp: 0, prodCondensorTemp: 0, radiatorTemp: 0, boilerTemp: 0, timeStamp: 0 };
        if (value !== undefined)
            reflectionMergePartial<TemperatureData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TemperatureData): TemperatureData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double headTemp */ 1:
                    message.headTemp = reader.double();
                    break;
                case /* double refluxCondensorTemp */ 2:
                    message.refluxCondensorTemp = reader.double();
                    break;
                case /* double prodCondensorTemp */ 3:
                    message.prodCondensorTemp = reader.double();
                    break;
                case /* double radiatorTemp */ 4:
                    message.radiatorTemp = reader.double();
                    break;
                case /* double boilerTemp */ 5:
                    message.boilerTemp = reader.double();
                    break;
                case /* uint32 timeStamp */ 6:
                    message.timeStamp = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TemperatureData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double headTemp = 1; */
        if (message.headTemp !== 0)
            writer.tag(1, WireType.Bit64).double(message.headTemp);
        /* double refluxCondensorTemp = 2; */
        if (message.refluxCondensorTemp !== 0)
            writer.tag(2, WireType.Bit64).double(message.refluxCondensorTemp);
        /* double prodCondensorTemp = 3; */
        if (message.prodCondensorTemp !== 0)
            writer.tag(3, WireType.Bit64).double(message.prodCondensorTemp);
        /* double radiatorTemp = 4; */
        if (message.radiatorTemp !== 0)
            writer.tag(4, WireType.Bit64).double(message.radiatorTemp);
        /* double boilerTemp = 5; */
        if (message.boilerTemp !== 0)
            writer.tag(5, WireType.Bit64).double(message.boilerTemp);
        /* uint32 timeStamp = 6; */
        if (message.timeStamp !== 0)
            writer.tag(6, WireType.Varint).uint32(message.timeStamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const TemperatureData = new TemperatureData$Type();
/**
 * Type for protobuf message DeviceData
 */
class DeviceData$Type extends MessageType<DeviceData> {
    constructor() {
        super("DeviceData", [
            { no: 1, name: "sensors", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DS18B20Sensor }
        ]);
    }
    create(value?: PartialMessage<DeviceData>): DeviceData {
        const message = { sensors: [] };
        if (value !== undefined)
            reflectionMergePartial<DeviceData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceData): DeviceData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated DS18B20Sensor sensors */ 1:
                    message.sensors.push(DS18B20Sensor.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated DS18B20Sensor sensors = 1; */
        for (let i = 0; i < message.sensors.length; i++)
            DS18B20Sensor.internalBinaryWrite(message.sensors[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const DeviceData = new DeviceData$Type();
